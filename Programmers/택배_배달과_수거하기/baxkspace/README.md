## Info
Programmers - 택배 배달과 수거하기 https://school.programmers.co.kr/learn/courses/30/lessons/150369

## How to solve
* 처음에 했던 생각은 픽업 상자랑 배달 상자를 따로 돌리면서 두 개를 합쳤을 때 cap이 넘어가는지 매번 판단해야
하나? 였음. 근데 아무리 생각해도 너무 번거로움.
* 한 번 길을 나설 때 가는 길에는 배달 ㅡ 오는 길에는 픽업이기 때문에 나눠서 생각할 필요가 없음. 한 번에 돌리면서 둘 중에 하나가 cap을 넘어가면 거기까지 더하면 됨.


####  ▶ Greedy algorithm
    눈앞에 보이는 최적의 상황만을 쫓아 최종적인 해답에 도달하는 방법.

이 문제의 경우 어떤 경우이든 가장 먼 곳에 있는 것부터 들른 후 상자를 픽업하는 과정이 필요함.


* **코드 설명**
  * 출발할 때의 픽업 상자 개수는 0, 배달 상자의 개수를 cap개로 초기화함.
  * 제시된 두 배열을 끝에서부터 돌면서 각각 픽업에 더하기, 배달 상자에는 마이너스를 함.
  * 연산하고 난 후 만약 픽업 상자의 개수가 0보다 크거나, 배달 상자의 개수가 cap보다 작아진다면 -> 그 지점이 들러야 하는 최대 거리가 됨.
  * 돌아가는 과정에서 들고 갈 수 있는 상자의 개수를 고려해 주기 위해 각각 픽업에는 cap을 빼 주고, 배달에는 cap을 더해 줬음. (ex - 뺀 연산에서 pick이 -2라면 돌아가는 과정에서 2개의 박스를 더 픽업해 갈 수 있음)
  * while문 안에서 가야 하는 최대의 거리를 answer에 더해 줌.
  * 배열 0번째까지 순회하며 반복.
  * 왕복 거리이기 때문에 answer은 2를 곱해서 리턴해 준다.
  
## etc
* 배열의 숫자를 관리하면서 돌리는 방법을 시도해 봤을 때 관리해야 하는 배열의 수가 많아짐. 두 배열을 전부 순회하면 반복문도 많이 돌아가게 됨.
* 매번 배열에서만 관리하는 방식으로 돌렸는데 변수로 숫자 관리가 가능한 방법을 알아 냄! 뿌듯. ☺
* 그리고 무엇보다 코드가 깔끔함...