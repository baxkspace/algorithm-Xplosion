## Info
BOJ [2579] 계단 오르기 https://www.acmicpc.net/problem/2579

## How to solve
##### 📌 Dynamic Programming
```
> 하나의 큰 문제를 여러 개의 작은 문제로 나누어 그 결과를 저장해
  다시 큰 문제를 해결할 때 사용하는 방식.
```
* __DP를 사용하기 위한 조건__
    1) Overlapping Subproblems (겹치는 부분 문제)
    2) Optimal Substructure(최적 부분 구조)
       * 이때 최적 부분 구조란 부분 문제의 최적 결과 값을 사용해 전체 문제의 최적 결과를 낼 수 있는 경우를 말한다. 대표적인 DP 문제인 피보나치 수열도 이 경우에 해당!
       
***
* 변수는 계단의 개수, 계단 점수 리스트, dp를 계산하기 위한 배열로 크게 세 개가 사용됨
1) 계단의 수가 두 개 이하인 경우
    * 무조건 두 개를 모두 밟는 것이 가장 큰 점수. stair의 배열 값을 모두 sum 한 값을 프린트해 준다.
   

2) 계단의 수가 두 개 이상인 경우
   * 기본적인 조건으로 마지막 계단은 무조건 밟아야 하며, 세 개 이상의 계단을 연속해서 밟을 수는 없음.
   * 마지막 계단을 무조건 밟는다는 전제 하에 각 계단에서는 두 가지 경우가 있음 -> 두 개를 모두 밟는 경우, 한 계단을 건너뛴 경우
   * 위 조건에 따라 두 가지 경우를 계산해 dp를 갱신해 줌. 
     * 두 개를 모두 밟는 경우: dp[i-3] + stairs[i-1] + stairs[i]
     * 한 계단을 건너 뛰는 경우: dp[i-2] + stairs[i]
   
## etc
* dp는 간단한 원리랑 케이스만 잘 계산하면 코드가 깔끔하게 구현이 된다는 점에서 좋음. 물론 점화식 쓰는 데 계산이 좀 필요하지만.
* https://www.acmicpc.net/problem/1463 이 문제가 방식 생각하는 데 도움이 됐음.